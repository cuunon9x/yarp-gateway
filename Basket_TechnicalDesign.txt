BasketAPI Microservice Technical Design Document
Version: 1.0
Date: June 1, 2025
Author: TrinhCV
Table of Contents
1. Introduction
2. Application Use Cases
3. Architecture Overview
4. Core Technologies & Libraries
5. Design Patterns & Principles
6. Domain Models
7. REST API Endpoints of Basket Microservice
8. Implementation Details
   * 8.1. Infrastructure & Data Interaction
   * 8.2. gRPC Basket Operations
   * 8.3. Asynchronous Basket Operations
   * 8.4. Validation & Object Mapping
   * 8.5. Decorator Pattern Implementation with Scrutor
9. Project Folder Structure
10. Monitoring & Operations
   * 10.1. Health Checks in ASP.NET Core
   * 10.2. Containerization
1. Introduction
This document outlines the technical design and architectural patterns employed in the development of the Basket Microservice (BasketAPI). This service is a crucial component within the overall microservices architecture, responsible for managing user shopping carts and facilitating the checkout process. It is designed for easy integration and management with other services, leveraging the same modern .NET technologies and architectural principles as the Catalog Microservice to ensure high performance, maintainability, and extensibility.
2. Application Use Cases
The Basket Microservice handles all operations related to a user's shopping cart. This includes standard CRUD operations, integration with a Discount service via gRPC, and asynchronous event publishing for checkout.
CRUD Basket Operations:
* Get ShoppingCart with Items: Retrieve a user's entire shopping cart, including all items within it.
* Store (Upsert - Create and Update) ShoppingCart with Items: Create a new shopping cart or update an existing one. This encompasses:
   * Add Item into ShoppingCart: Add a new product to the cart.
   * Remove Item from ShoppingCart: Remove a specific product from the cart.
   * Update ShoppingCartItem into ShoppingCart (increase Quantity): Modify the quantity of an existing item in the cart.
* Delete ShoppingCart with Items: Remove a user's entire shopping cart.
gRPC Basket Operations:
* When Store Basket: GetDiscount and deduct discount coupon from Item Price: During the process of storing or updating a shopping cart, the BasketAPI will interact with the Discount microservice via gRPC to apply any relevant discount coupons and adjust item prices accordingly.
Async Basket Operations:
* Checkout Basket and Publish event to RabbitMQ Message Broker: When a user proceeds to checkout, the BasketAPI will process the basket and publish a "Checkout" event to a RabbitMQ Message Broker. This asynchronous communication will trigger subsequent processes in other microservices (e.g., Ordering microservice).
3. Architecture Overview
The Basket Microservice is an integral part of the larger microservices ecosystem. It is containerized using Docker and interacts with Redis for data storage, the Discount microservice via gRPC, and RabbitMQ for asynchronous communication.
Overall Microservices Architecture:
* Client Apps (e.g., Shopping.Web): Interact with the microservices through an API Gateway.
* Yarp API Gateway: Routes incoming requests from client applications to the appropriate microservices (Catalog, Basket, Discount, Ordering).
* Basket Microservice:
   * Data Store: Utilizes both Redis and Marten (PostgreSQL) for storing shopping cart data.
   * Inter-service Communication:
      * Communicates with the Discount microservice via gRPC for real-time discount calculations.
      * Communicates asynchronously with the Ordering microservice (and potentially others) via RabbitMQ for checkout events.
* Other Microservices: Catalog (PostgreSQL), Discount (SQLite), Ordering (SQL).
* Containerization: All microservices are deployed as Docker containers.
Internal "Basket" Microservice Architecture:
Similar to the Catalog Microservice, the BasketAPI will adhere to a Vertical Slice Architecture combined with CQRS (Command Query Responsibility Segregation) for internal organization and maintainability.
4. Core Technologies & Libraries
The Basket Microservice will utilize a similar technology stack to the Catalog Microservice, with key additions for its specific responsibilities:
* .NET 8 (ASP.NET Core): The foundational framework for building the web API.
* Redis: A high-performance in-memory data store and distributed cache used for storing frequently accessed shopping cart data.
* Marten: A powerful library that transforms PostgreSQL into a .NET Transactional Document DB, leveraging PostgreSQL's JSON column features for storing, querying, and managing documents.
* gRPC: For efficient, high-performance inter-service communication with the Discount microservice.
* RabbitMQ: A robust message broker used for asynchronous communication and event publishing (e.g., Checkout events).
* MediatR: Simplifies CQRS implementation and in-process messaging.
* Carter: For defining lightweight and clean REST API endpoints.
* Mapster: For efficient object mapping.
* FluentValidation: For building strongly-typed input validation rules.
* Docker: For containerization and consistent deployment.
* Scrutor: For simplified assembly scanning and automatic service registration in Dependency Injection, particularly useful for implementing patterns like Decorator.
* StackExchange.Redis: A high-performance C# client for Redis.
* MassTransit: A distributed application framework for .NET, simplifying message-based communication with RabbitMQ.
5. Design Patterns & Principles
The Basket Microservice will apply the same robust design patterns and principles as the Catalog Microservice to ensure consistency, maintainability, and scalability across the microservices landscape, with the addition of the Repository Pattern and Decorator Pattern:
* Repository Pattern: A Domain-Driven Design (DDD) pattern used to keep persistence concerns outside of the system's domain model. It provides an abstraction of data, allowing the application to work with simple abstraction interfaces for data access, promoting loose coupling and testability.
* Decorator Pattern: Allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. In this context, it will be used to add cross-cutting concerns like caching to a repository implementation without modifying the core repository logic.
* CQRS Pattern (Command Query Responsibility Segregation): Separates read (queries) and write (commands) operations.
* Mediator Pattern: Facilitates object interaction through MediatR, reducing direct dependencies.
* Dependency Injection (DI): Ensures loose coupling and testability.
* Minimal APIs and Routing in ASP.NET 8: Provides a lightweight syntax for defining API endpoints.
6. Domain Models
The primary domain models for the Basket Microservice are ShoppingCart, ShoppingCartItem, and Basket Checkout.
ShoppingCart Model:
public class ShoppingCart
{
   public string UserName { get; set; } // Unique identifier for the shopping cart
   public List<ShoppingCartItem> Items { get; set; } = new List<ShoppingCartItem>();
   public decimal TotalPrice { get; set; } // Calculated total price of items in the cart
   // Other properties like CreatedDate, LastUpdatedDate, etc.
}

public class ShoppingCartItem
{
   public Guid ProductId { get; set; }
   public string ProductName { get; set; }
   public int Quantity { get; set; }
   public decimal UnitPrice { get; set; }
   public string ImageFile { get; set; }
   // Potentially other properties like Color, Size, etc.
}

* Relationship: A ShoppingCart contains a list of ShoppingCartItems.
* Basket Checkout Domain Event: Consider defining a BasketCheckout domain event. This event would be raised when a user initiates the checkout process and would lead to the publication of integration events to the message broker, facilitating communication with other microservices (e.g., Ordering).
7. REST API Endpoints of Basket Microservice
The Basket Microservice will expose the following RESTful API endpoints:
Method
	Request URI
	Use Cases
	GET
	/basket/{userName}
	Get shopping cart by username
	POST
	/basket/{userName}
	Store Basket (Upsert: Create/Update)
	DELETE
	/basket/{userName}
	Delete shopping cart by username
	POST
	/basket/checkout
	Checkout basket
	8. Implementation Details
8.1. Infrastructure & Data Interaction
* Basket Microservices has 2 Datastore:
   * Marten Document Database: Marten is a powerful library that transforms PostgreSQL into a .NET Transactional Document DB using PostgreSQL's JSON column features. This will be used for persistent storage of shopping cart data, providing reliability and rich querying capabilities.
   * Redis Distributed Cache: Redis is a powerful in-memory data store and distributed cache. It will be used for frequently accessed shopping cart data to provide high-performance retrieval and updates, acting as a caching layer or primary store for transient cart data.
* Data Serialization: ShoppingCart objects will be serialized (e.g., to JSON) before being stored in Marten/Redis and deserialized upon retrieval.
8.2. gRPC Basket Operations
* Discount Service Integration: When a shopping cart is stored or updated, the BasketAPI will make a gRPC call to the Discount microservice.
* Discount Application: The gRPC request will include details necessary for discount calculation (e.g., item prices, coupon codes). The Discount service will return the applied discount or adjusted prices, which the BasketAPI will then use to update the TotalPrice of the ShoppingCart and potentially individual ShoppingCartItem prices.
8.3. Asynchronous Basket Operations
* Checkout Process: The /basket/checkout endpoint will trigger the checkout process.
* Event Publishing: Upon successful processing of the checkout, the BasketAPI will publish a BasketCheckoutEvent (or similar) to the RabbitMQ Message Broker using MassTransit. This event will contain all necessary information for downstream services (e.g., the Ordering microservice) to fulfill the order.
* Reliability: Mechanisms for ensuring reliable message delivery (e.g., acknowledgments, retries, dead-letter queues) will be considered for RabbitMQ integration.
8.4. Validation & Object Mapping
* FluentValidation: Will be used to define and apply validation rules for incoming requests (e.g., ensuring item quantities are positive, valid product IDs). This will be integrated into the MediatR pipeline as a behavior.
* Mapster: Will handle object mapping between DTOs (Data Transfer Objects) used in API requests/responses and the internal domain models (ShoppingCart, ShoppingCartItem).
8.5. Decorator Pattern Implementation with Scrutor
The Decorator Pattern will be implemented for cross-cutting concerns, such as caching, on repository interfaces using the Scrutor library for simplified registration.
1. Define Interface & Base Implementation:
   * Start by defining a repository interface, for example, IBasketRepository, which declares the data access operations for the ShoppingCart domain.
   * Create a base implementation of this interface, e.g., BasketRepository, which contains the core logic for interacting with Marten and/or Redis.
// Example: Interface
public interface IBasketRepository
{
   Task<ShoppingCart> GetBasketAsync(string userName);
   Task StoreBasketAsync(ShoppingCart basket);
   Task DeleteBasketAsync(string userName);
}

// Example: Base Implementation
public class BasketRepository : IBasketRepository
{
   private readonly IDocumentStore _documentStore; // Marten
   private readonly IConnectionMultiplexer _redis; // StackExchange.Redis

   public BasketRepository(IDocumentStore documentStore, IConnectionMultiplexer redis)
   {
       _documentStore = documentStore;
       _redis = redis;
   }

   public async Task<ShoppingCart> GetBasketAsync(string userName)
   {
       // Core logic to get basket from Marten or Redis
       // Example: Get from Redis first, then Marten if not found
       var db = _redis.GetDatabase();
       var cachedBasket = await db.StringGetAsync(userName);
       if (!string.IsNullOrEmpty(cachedBasket))
       {
           return JsonSerializer.Deserialize<ShoppingCart>(cachedBasket);
       }

       using var session = _documentStore.QuerySession();
       var basket = await session.LoadAsync<ShoppingCart>(userName);
       if (basket != null)
       {
           await db.StringSetAsync(userName, JsonSerializer.Serialize(basket)); // Cache it
       }
       return basket;
   }

   public async Task StoreBasketAsync(ShoppingCart basket)
   {
       // Core logic to store basket in Marten and update Redis
       using var session = _documentStore.LightweightSession();
       session.Store(basket);
       await session.SaveChangesAsync();

       var db = _redis.GetDatabase();
       await db.StringSetAsync(basket.UserName, JsonSerializer.Serialize(basket));
   }

   public async Task DeleteBasketAsync(string userName)
   {
       // Core logic to delete basket from Marten and Redis
       using var session = _documentStore.LightweightSession();
       session.Delete<ShoppingCart>(userName);
       await session.SaveChangesAsync();

       var db = _redis.GetDatabase();
       await db.KeyDeleteAsync(userName);
   }
}

2. Create Decorator:
   * Create a decorator class, e.g., CachedBasketRepository, that also implements IBasketRepository.
   * This decorator will take an instance of IBasketRepository (the "decorated" service) as a dependency.
   * It will add cross-cutting logic (e.g., caching, logging) before or after calling the methods of the decorated service.
// Example: Decorator for Caching
public class CachedBasketRepository : IBasketRepository
{
   private readonly IBasketRepository _decorated;
   private readonly IConnectionMultiplexer _redis; // For caching logic

   public CachedBasketRepository(IBasketRepository decorated, IConnectionMultiplexer redis)
   {
       _decorated = decorated;
       _redis = redis;
   }

   public async Task<ShoppingCart> GetBasketAsync(string userName)
   {
       var db = _redis.GetDatabase();
       var cachedBasket = await db.StringGetAsync(userName);
       if (!string.IsNullOrEmpty(cachedBasket))
       {
           Console.WriteLine($"Getting basket {userName} from cache.");
           return JsonSerializer.Deserialize<ShoppingCart>(cachedBasket);
       }

       Console.WriteLine($"Getting basket {userName} from underlying repository.");
       var basket = await _decorated.GetBasketAsync(userName); // Call the base implementation
       if (basket != null)
       {
           await db.StringSetAsync(userName, JsonSerializer.Serialize(basket), TimeSpan.FromMinutes(5)); // Cache for 5 minutes
       }
       return basket;
   }

   public async Task StoreBasketAsync(ShoppingCart basket)
   {
       Console.WriteLine($"Storing basket {basket.UserName} and updating cache.");
       await _decorated.StoreBasketAsync(basket); // Call the base implementation
       var db = _redis.GetDatabase();
       await db.StringSetAsync(basket.UserName, JsonSerializer.Serialize(basket), TimeSpan.FromMinutes(5)); // Update cache
   }

   public async Task DeleteBasketAsync(string userName)
   {
       Console.WriteLine($"Deleting basket {userName} and invalidating cache.");
       await _decorated.DeleteBasketAsync(userName); // Call the base implementation
       var db = _redis.GetDatabase();
       await db.KeyDeleteAsync(userName); // Invalidate cache
   }
}

3. Register Services with Scrutor:
   * In Program.cs (or your DI configuration), use Scrutor's Decorate method to register the base implementation and then apply the decorator. This ensures that when IBasketRepository is requested, the CachedBasketRepository is returned, wrapping the BasketRepository.
// Example: Program.cs or Startup.cs
using Scrutor;
using StackExchange.Redis; // Assuming Redis is configured and available

// ... other service registrations ...

// Register the base repository implementation
builder.Services.AddScoped<IBasketRepository, BasketRepository>();

// Decorate the IBasketRepository with CachedBasketRepository
// This means any request for IBasketRepository will get CachedBasketRepository,
// which in turn uses the BasketRepository
builder.Services.Decorate<IBasketRepository, CachedBasketRepository>();

// Ensure Redis is also registered, as CachedBasketRepository depends on it
builder.Services.AddSingleton<IConnectionMultiplexer>(ConnectionMultiplexer.Connect("localhost")); // Or your Redis connection string

This setup allows for adding caching logic (or other cross-cutting concerns like logging, error handling, etc.) without modifying the core BasketRepository implementation, adhering to the Open/Closed Principle.
9. Project Folder Structure
The project folder structure will follow the same Vertical Slice Architecture principles as the Catalog Microservice, promoting modularity and clear separation of concerns:
* Model: Contains domain models (ShoppingCart, ShoppingCartItem, BasketCheckout).
* Features: Houses individual feature implementations (e.g., GetBasket, StoreBasket, DeleteBasket, CheckoutBasket). Each feature will have its Commands/Queries, Handlers, and validators.
* Data: Manages data persistence logic, including Marten and Redis interactions, potentially implementing the Repository Pattern interfaces. This is where IBasketRepository, BasketRepository, and CachedBasketRepository would reside.
* Abstractions: Stores interfaces and common contracts (e.g., Repository interfaces).
10. Monitoring & Operations
The Basket Microservice will incorporate robust monitoring and operational capabilities, mirroring the approach taken with the Catalog Microservice:
10.1. Health Checks in ASP.NET Core
Health checks in ASP.NET Core provide a way to monitor the status of your application and its dependencies.
* Purpose: To monitor the operational status of the BasketAPI and its critical dependencies, including the PostgreSQL database, Redis database, and RabbitMQ connection.
* Implementation: Health checks will be added to our Basket microservices with checking the health of our PostgreSQL database, Redis database, and RabbitMQ connection.
* Exposure: Health checks are exposed by an app as HTTP endpoints. Health check endpoints can be configured for various real-time monitoring scenarios.
* Benefits: A container orchestrator may respond to a failing health check by halting a rolling deployment or restarting a container. A load balancer might react to an unhealthy app by routing traffic away from the failing instance to a healthy instance.
10.2. Containerization
* The Basket Microservice will be packaged into a Docker container, facilitating consistent deployment, environment isolation, and scalability within the microservices ecosystem.